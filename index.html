<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Technical Documentation</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <nav id="navbar">
            <header>Rules for Developing Safety Critical Code</header>
            <ul>
                <li><a class="nav-link" href="#Before_we_start">Before we start</a></li>
                <li><a class="nav-link" href="#Introduction">Introduction</a></li>
                <li><a class="nav-link" href="#Safety-critical_coding_rules">Safety-critical coding rules</a></li>
                <li><a class="nav-link" href="#Rule_1">Rule 1</a></li>
                <li><a class="nav-link" href="#Rule_2">Rule 2</a></li>
                <li><a class="nav-link" href="#Rule_3">Rule 3</a></li>
                <li><a class="nav-link" href="#Rule_4">Rule 4</a></li>
                <li><a class="nav-link" href="#Rule_5">Rule 5</a></li>
                <li><a class="nav-link" href="#Rule_6">Rule 6</a></li>
                <li><a class="nav-link" href="#Rule_7">Rule 7</a></li>
                <li><a class="nav-link" href="#Rule_8">Rule 8</a></li>
                <li><a class="nav-link" href="#Rule_9">Rule 9</a></li>
                <li><a class="nav-link" href="#Rule_10">Rule 10</a></li>
                <li><a class="nav-link" href="#Following_the_rules">Following The Rules</a></li>
            </ul>
        </nav>
        <main id="main-doc">
            <section id="Before_we_start" class="main-section">
                <header>Before we start</header>
            </section>
            <section id="Introduction" class="main-section">
                <header>Introduction</header>
                <article>
                    <p>Adhering to a set of 10 verifiable coding rules can
                       make the analysis of critical software domponents more
                       reliable.</p>
                    <p>Most serious software development projects use coding guidelines. These guidelines are meant to define the ground
                       rules for the software to be written: how it should be structured and which language features should and should not be
                       used. Curiously, there is little consensus on what a good coding standard is.</p>
                    <p>Among the many coding guidelines that have been written, there are remarkably few patterns to discern, except that each
                       new document tends to be longer than the one before it. The result is that most existing guidelines contain well over 100
                       rules, sometimes with questionable justification. Some rules, especially those that try to stipulate the use of white space
                       in programs, might have been introduced by personal preference; others are meant to prevent very specific and unlikely
                       types of errors from earlier coding efforts within the same organization.</p>
                    <p>Not surprisingly, the existing coding guidelines tend to have little effect on what developers actually do when they write
                       code. The most dooming aspect of many of the guidelines is that they rarely allow for comprehensive tool-based
                       compliance checks. Tool-based checks are important because manually reviewing the hundreds of thousands of lines of
                       code that are written for larger applications is often infeasible.</p>
                    <p>Existing coding guidelines therefore offer limited benefit, even for critical applications. A verifiable set of well-chosen
                       coding rules could, however, assist in analyzing critical software components for properties that go well beyond
                       compliance with the set of rules itself. To be effective, though, the set of rules must be small, and it must be clear enough
                       that users can easily understand and remember it. In addition, the rules must be specific enough that users can check
                       them thoroughly and mechanically.</p>
                    <p>To put an upper bound on the number of rules, I will argue that restricting the set to no more than 10 rules will provide an
                       effective guideline. Although such a small set of rules cannot be all-encompassing, following it can achieve measurable
                       effects on software reliability and verifiability.</p>
                    <p>To support strong checking, the rules I will propose are somewhat strict—some might even say draconian. The tradeoff,
                       though, should be clear. When it really counts, especially in the development of safety-critical code, working within stricter
                       limits can be worth the extra effort. In return, it should be possible to demonstrate more convincingly that critical software
                       will work as intended.</p>
                </article>
            </section>
            <section id="Safety-critical_coding_rules" class="main-section">
                <header>Safety-critical coding rules</header>
                <article>
                    <p>The choice of language for safety-critical code is in itself a key consideration. At many organizations, JPL included,
                       developers write most code in C. With its long history, there is extensive tool support for this language, including strong
                       source code analyzers, logic model extractors, metrics tools, debuggers, test-support tools, and a choice of mature, stable
                       compilers. For this reason, C is also the target of the majority of existing coding guidelines. For fairly pragmatic reasons,
                       then, the following 10 rules primarily target C and attempt to optimize the ability to more thoroughly check the reliability
                       of critical applications written in C.</p>
                    <p>These rules might prove to be beneficial, especially if the small number means that developers will actually adhere to
                       them.</p>
                </article>
            </section>
            <section id="Rule_1" class="main-section">
                <div>
                    <header>Rule 1</header>:
                    <p>Restrict all code to very simple control flow constructs—do not use</p>
                    <ul>
                        <li><code>goto</code> statements</li>
                        <li><code>setjmp</code> constructs</li>
                        <li><code>longjmp</code> constructs</li>
                        <li>direct recursion</li>
                        <li>indirect recursion</li>
                    </ul>
                </div>
                <article>
                    <p><span>Rationale</span> : Simpler control flow translates into stronger capabilities for analysis and often results in improved code clarity.
                        Banishing recursion is perhaps the biggest surprise here. Avoiding recursion results in having an acyclic function call
                        graph, which code analyzers can exploit to prove limits on stack use and boundedness of executions. Note that this rule
                        does not require that all functions have a single point of return, although this often also simplifies control flow. In some
                        cases, though, an early return is the simpler solution.
                    </p>
                </article>
            </section>
            <section id="Rule_2" class="main-section">
                <div>
                    <header>Rule 2</header>:
                    <p>Give all loops a fixed upper bound. It must be trivially possible for a checking tool to prove statically that the loop
                       cannot exceed a preset upper bound on the number of iterations. If a tool cannot prove the loop bound statically, the rule
                       is considered violated.
                    </p>
                </div>
                <article>
                    <p><span>Rationale</span> : The absence of recursion and the presence of loop bounds prevents runaway code. This rule does not, of
                        course, apply to iterations that are meant to be nonterminating—for example, in a process scheduler. In those special
                        cases, the reverse rule is applied: It should be possible for a checking tool to prove statically that the iteration cannot
                        terminate.</p>
                    <p>One way to comply with this rule is to add an explicit upper bound to all loops that have a variable number of
                        iterations—for example, code that traverses a linked list. When the loop exceeds the upper bound, it must trigger an
                        assertion failure, and the function containing the failing iteration should return an error.</p>
                </article>
            </section>
            <section id="Rule_3" class="main-section">
                <div>
                    <header>Rule 3</header>:
                    <p>Do not use dynamic memory allocation after initialization.</p>
                </div>
                <article>
                    <p><span>Rationale</span> : This rule appears in most coding guidelines for safety-critical software. The reason is simple: Memory
                        allocators, such as malloc, and garbage collectors often have unpredictable behavior that can significantly impact
                        performance.</p>
                    <p>A notable class of coding errors also stems from the mishandling of memory allocation and free routines: forgetting to free
                        memory or continuing to use memory after it was freed, attempting to allocate more memory than physically available,
                        overstepping boundaries on allocated memory, and so on. Forcing all applications to live within a fixed, preallocated area
                        of memory can eliminate many of these problems and make it easier to verify memory use.</p>
                    <p>Note that the only way to dynamically claim memory in the absence of memory allocation from the heap is to use stack
                        memory. In the absence of recursion, an upper bound on the use of stack memory can be derived statically, thus making
                        it possible to prove that an application will always live within its resource bounds.</p>
                </article>
            </section>
            <section id="Rule_4" class="main-section">
                <div>
                    <header>Rule 4</header>:
                    <p>No function should be longer than what can be printed on a single sheet of paper in a standard format with one
                        line per statement and one line per declaration. Typically, this means no more than about 60 lines of code per function.</p>
                </div>
                <article>
                    <p><span>Rationale</span> : Each function should be a logical unit in the code that is understandable and verifiable as a unit. It is much
                        harder to understand a logical unit that spans multiple pages. Excessively long functions are often a sign of poorly
                        structured code.</p>
                </article>
            </section>
            <section id="Rule_5" class="main-section">
                <header>Rule 5</header>
            </section>
            <section id="Rule_6" class="main-section">
                <header>Rule 6</header>
            </section>
            <section id="Rule_7" class="main-section">
                <header>Rule 7</header>
            </section>
            <section id="Rule_8" class="main-section">
                <header>Rule 8</header>
            </section>
            <section id="Rule_9" class="main-section">
                <header>Rule 9</header>
            </section>
            <section id="Rule_10" class="main-section">
                <header>Rule 10</header>
            </section>
            <section id="#Following_the_rules" class="main-section">
                <header>Following the rules</header>
            </section>
        </main>
    </body>
</html>